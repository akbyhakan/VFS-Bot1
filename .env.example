# VFS Credentials
VFS_EMAIL=your_email@example.com
# ⚠️ Do NOT set VFS_PASSWORD manually here!
# Use the setup script for secure password handling:
#   python scripts/setup_environment.py
# VFS_PASSWORD is managed by the application (encrypted in database)
VFS_PASSWORD=your_password

# Password Encryption Key (CRITICAL - Generate with: python -c "from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())")
ENCRYPTION_KEY=your-base64-encoded-encryption-key-here

# VFS API Encryption (CRITICAL - Generate a secure 32-byte key)
# This is used for encrypting passwords when authenticating with VFS API
# Generate with: python -c "import secrets; print(secrets.token_urlsafe(32))"
VFS_ENCRYPTION_KEY=your-32-byte-encryption-key-here

# ===========================================
# Database Configuration
# ===========================================
# PostgreSQL connection URL
# Format: postgresql://username:password@host:port/database
# 
# ⚠️ IMPORTANT FOR DOCKER USERS:
# When running with Docker Compose, the DATABASE_URL is automatically set
# by the docker-compose.yml file using the service name 'postgres' as the host.
# You should still set POSTGRES_PASSWORD below.
# 
# For local development without Docker, use:
DATABASE_URL=postgresql://vfs_bot:changeme@localhost:5432/vfs_bot
# PostgreSQL password (used by Docker Compose)
# ⚠️ CRITICAL: Change this to a secure password before deploying!
POSTGRES_PASSWORD=changeme
# Connection pool size
DB_POOL_SIZE=10
DB_CONNECTION_TIMEOUT=30.0

# ===========================================
# API Configuration
# ===========================================

# VFS API Base URLs (optional - defaults provided)
VFS_API_BASE=https://lift-api.vfsglobal.com
VFS_ASSETS_BASE=https://liftassets.vfsglobal.com
CONTENTFUL_BASE=https://d2ab400qlgxn2g.cloudfront.net/dev/spaces

# Token Management
TOKEN_REFRESH_BUFFER_MINUTES=5

# ===========================================
# Logging
# ===========================================
LOG_LEVEL=INFO
LOG_FORMAT=text  # text or json (json recommended for production)

# ===========================================
# Environment
# ===========================================
ENV=production  # production or development

# ===========================================
# Telegram Notifications
# ===========================================
TELEGRAM_BOT_TOKEN=your_bot_token
TELEGRAM_CHAT_ID=your_chat_id

# ===========================================
# Email Notifications
# ===========================================
EMAIL_SENDER=your_email@gmail.com
EMAIL_PASSWORD=your_app_password
EMAIL_RECEIVER=receiver@example.com

# ===========================================
# Captcha Service
# ===========================================
CAPTCHA_API_KEY=your_captcha_api_key

# ===========================================
# SMS OTP Webhook
# ===========================================
SMS_WEBHOOK_SECRET=your-webhook-secret-for-signature-verification
OTP_TIMEOUT_SECONDS=300

# ===========================================
# Microsoft 365 Email OTP Configuration
# ===========================================
# Email address for catch-all mailbox (receives all bot OTPs)
M365_EMAIL=admin@yourdomain.com
# Microsoft 365 App Password (generate from account.microsoft.com/security)
M365_APP_PASSWORD=xxxx-xxxx-xxxx-xxxx

# ===========================================
# OTP Manager Configuration (Centralized)
# ===========================================
# Centralized OTP management for 100-150+ bot sessions
# Uses single IMAP connection with catch-all mailbox
OTP_MANAGER_EMAIL=your-catchall-email@yourdomain.com
OTP_MANAGER_APP_PASSWORD=your-app-specific-password
OTP_MANAGER_TIMEOUT=120
OTP_MANAGER_SESSION_TIMEOUT=600

# ===========================================
# SMS Webhook Token Configuration
# ===========================================
# Base URL for webhook endpoints (used for generating webhook URLs)
WEBHOOK_BASE_URL=https://your-api-domain.example.com
# Token prefix for webhook tokens (default: tk_)
WEBHOOK_TOKEN_PREFIX=tk_
# Rate limit for webhook endpoints (requests per minute per IP)
WEBHOOK_RATE_LIMIT=60
# Optional HMAC signature secret for webhook payload verification
WEBHOOK_SIGNATURE_SECRET=

# ===========================================
# Dashboard Security
# ===========================================
DASHBOARD_API_KEY=your-secure-api-key-here
ADMIN_SECRET=one-time-secret-for-key-generation

# ===========================================
# API Authentication (JWT)
# ===========================================

# CRITICAL: Must be at least 64 characters for security (256-bit)
# Generate with: python -c "import secrets; print(secrets.token_urlsafe(48))"
API_SECRET_KEY=your-secret-key-here-must-be-at-least-64-characters-long-for-security
JWT_ALGORITHM=HS256
JWT_EXPIRY_HOURS=24

# Admin Credentials (required for JWT login)
# CRITICAL: Change this password immediately!
# For production, use hashed password. Generate with: python -c "from passlib.context import CryptContext; print(CryptContext(schemes=['bcrypt']).hash('your-password'))"
# ⚠️ Change to a unique username - never use 'admin' in production!
ADMIN_USERNAME=your_unique_admin_name
# ⚠️ MUST be a bcrypt hash in production. Generate with:
#   python scripts/setup_environment.py
ADMIN_PASSWORD=YOUR_SECURE_HASHED_PASSWORD_HERE

# Optional API Key Auth (alternative to JWT)
API_KEY=your-api-key-here

# API Key Salt (CRITICAL - Required in production)
# Generate with: python -c "import secrets; print(secrets.token_urlsafe(32))"
API_KEY_SALT=your-32-character-minimum-salt-here

# API Key Version (for key rotation tracking)
API_KEY_VERSION=1

# Trusted Proxies (comma-separated IPs)
TRUSTED_PROXIES=

# ===========================================
# Health Check
# ===========================================
BOT_HEALTH_THRESHOLD=50.0

# ===========================================
# Cache Configuration
# ===========================================
# Cache time-to-live in seconds (default: 1 hour)
CACHE_TTL_SECONDS=3600

# ===========================================
# Rate Limiting
# ===========================================
RATE_LIMIT_REQUESTS=60
RATE_LIMIT_WINDOW=60

# Authentication rate limiting (brute-force protection)
AUTH_RATE_LIMIT_ATTEMPTS=5
AUTH_RATE_LIMIT_WINDOW=60

# ===========================================
# Sentry Monitoring (optional)
# ===========================================
SENTRY_DSN=https://your-key@sentry.io/project
SENTRY_TRACES_SAMPLE_RATE=0.1

# ===========================================
# AI-Powered Selector Auto-Repair (optional)
# ===========================================
# Enable AI-powered selector auto-repair using Google Gemini
# Get API key from: https://ai.google.dev/
GEMINI_API_KEY=your_gemini_api_key_here
