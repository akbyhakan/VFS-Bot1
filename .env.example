# VFS Credentials
VFS_EMAIL=your_email@example.com
# ⚠️ VFS_PASSWORD is managed securely by the application (encrypted in .env when using setup script).
# When using setup_environment.py, the password is automatically encrypted with Fernet.
# Manual setup: Set plain password and VFS_PASSWORD_ENCRYPTED=false
# VFS_PASSWORD=your_plain_password  (if VFS_PASSWORD_ENCRYPTED=false)
# VFS_PASSWORD=gAAAAABh...  (Fernet-encrypted when VFS_PASSWORD_ENCRYPTED=true)
VFS_PASSWORD_ENCRYPTED=false  # Set to true if password is Fernet-encrypted

# Password Encryption Key (CRITICAL - Generate with: python -c "from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())")
ENCRYPTION_KEY=your-base64-encoded-encryption-key-here

# Backup Encryption Key (uses ENCRYPTION_KEY if not set)
# Allows using a separate key for backup encryption
# BACKUP_ENCRYPTION_KEY=your-backup-specific-encryption-key

# VFS API Encryption (CRITICAL - Generate a secure 32-byte key)
# This is used for encrypting passwords when authenticating with VFS API
# Generate with: python -c "import secrets; print(secrets.token_urlsafe(32))"
VFS_ENCRYPTION_KEY=your-32-byte-encryption-key-here

# ===========================================
# Database Configuration
# ===========================================
# PostgreSQL connection URL
# Format: postgresql://username:password@host:port/database
# 
# ⚠️ IMPORTANT FOR DOCKER USERS:
# When running with Docker Compose, the DATABASE_URL is automatically set
# by the docker-compose.yml file using the service name 'postgres' as the host.
# You should still set POSTGRES_PASSWORD below.
# 
# For local development without Docker, use:
# ⚠️ CRITICAL: Replace with a strong, unique password before deploying!
# Generate with: python -c "import secrets; print(secrets.token_urlsafe(24))"
DATABASE_URL=postgresql://vfs_bot:CHANGE_ME_TO_SECURE_PASSWORD@localhost:5432/vfs_bot
# PostgreSQL password (used by Docker Compose)
# ⚠️ CRITICAL: Must match the password in DATABASE_URL above!
POSTGRES_PASSWORD=CHANGE_ME_TO_SECURE_PASSWORD
# Connection pool size
DB_POOL_SIZE=10
DB_CONNECTION_TIMEOUT=30.0

# Multi-worker pool size calculation
# Set these when running multiple workers to avoid exceeding PostgreSQL max_connections
# DB_MAX_CONNECTIONS=100
# DB_WORKER_COUNT=4

# ===========================================
# Database Backup Configuration
# ===========================================
# Backup interval in hours (default: 6)
BACKUP_INTERVAL_HOURS=6
# Number of days to retain backups (default: 30)
BACKUP_RETENTION_DAYS=30
# Backup directory (default: data/backups)
# BACKUP_DIR=data/backups

# ===========================================
# API Configuration
# ===========================================

# VFS API Base URLs (REQUIRED - obtain from your VFS integration)
VFS_API_BASE=https://your-vfs-api-base-url
VFS_ASSETS_BASE=https://your-vfs-assets-base-url
CONTENTFUL_BASE=https://your-contentful-base-url

# Token Management
TOKEN_REFRESH_BUFFER_MINUTES=5

# ===========================================
# Logging
# ===========================================
LOG_LEVEL=INFO
# JSON_LOGGING controls log output format (default: false for human-readable text logs)
# Set to true for structured JSON logs (recommended for production)
JSON_LOGGING=false

# ===========================================
# Environment
# ===========================================
ENV=production  # production or development

# ===========================================
# Telegram Notifications
# ===========================================
TELEGRAM_BOT_TOKEN=your_bot_token
TELEGRAM_CHAT_ID=your_chat_id

# ===========================================
# Email Notifications
# ===========================================
EMAIL_SENDER=your_email@gmail.com
EMAIL_PASSWORD=your_app_password
EMAIL_RECEIVER=receiver@example.com

# ===========================================
# Captcha Service
# ===========================================
CAPTCHA_API_KEY=your_captcha_api_key

# ===========================================
# SMS OTP Webhook
# ===========================================
SMS_WEBHOOK_SECRET=your-webhook-secret-for-signature-verification
OTP_TIMEOUT_SECONDS=300

# ===========================================
# Microsoft 365 Email OTP Configuration
# ===========================================
# Email address for catch-all mailbox (receives all bot OTPs)
M365_EMAIL=admin@yourdomain.com
# Microsoft 365 App Password (generate from account.microsoft.com/security)
M365_APP_PASSWORD=xxxx-xxxx-xxxx-xxxx

# ===========================================
# OTP Manager Configuration (Centralized)
# ===========================================
# Centralized OTP management for 100-150+ bot sessions
# Uses single IMAP connection with catch-all mailbox
OTP_MANAGER_EMAIL=your-catchall-email@yourdomain.com
OTP_MANAGER_APP_PASSWORD=your-app-specific-password
OTP_MANAGER_TIMEOUT=120
OTP_MANAGER_SESSION_TIMEOUT=600

# ===========================================
# SMS Webhook Token Configuration
# ===========================================
# Base URL for webhook endpoints (used for generating webhook URLs)
WEBHOOK_BASE_URL=https://your-api-domain.example.com
# Token prefix for webhook tokens (default: tk_)
WEBHOOK_TOKEN_PREFIX=tk_
# Rate limit for webhook endpoints (requests per minute per IP)
WEBHOOK_RATE_LIMIT=60
# Optional HMAC signature secret for webhook payload verification
WEBHOOK_SIGNATURE_SECRET=

# ===========================================
# Dashboard Security
# ===========================================
DASHBOARD_API_KEY=your-secure-api-key-here
ADMIN_SECRET=one-time-secret-for-key-generation

# ===========================================
# API Authentication (JWT)
# ===========================================

# CRITICAL: Must be at least 64 characters for security (256-bit)
# Generate with: python -c "import secrets; print(secrets.token_urlsafe(48))"
API_SECRET_KEY=your-secret-key-here-must-be-at-least-64-characters-long-for-security
JWT_ALGORITHM=HS384
JWT_EXPIRY_HOURS=24

# Admin Credentials (required for JWT login)
# CRITICAL: Change this password immediately!
# For production, use hashed password. Generate with: python -c "from passlib.context import CryptContext; print(CryptContext(schemes=['bcrypt']).hash('your-password'))"
# ⚠️ Change to a unique username - never use 'admin' in production!
ADMIN_USERNAME=your_unique_admin_name
# ⚠️ MUST be a bcrypt hash in production. Generate with:
#   python scripts/setup_environment.py
ADMIN_PASSWORD=YOUR_SECURE_HASHED_PASSWORD_HERE

# Optional API Key Auth (alternative to JWT)
API_KEY=your-api-key-here

# API Key Salt (CRITICAL - Required in production)
# Generate with: python -c "import secrets; print(secrets.token_urlsafe(32))"
API_KEY_SALT=your-32-character-minimum-salt-here

# API Key Version (for key rotation tracking)
API_KEY_VERSION=1

# Trusted Proxies (comma-separated IPs)
TRUSTED_PROXIES=

# ===========================================
# Health Check
# ===========================================
BOT_HEALTH_THRESHOLD=50.0

# ===========================================
# Cache Configuration
# ===========================================
# User cache TTL in seconds (used for graceful degradation when DB is unavailable)
USERS_CACHE_TTL=300

# Cache time-to-live in seconds (default: 1 hour)
CACHE_TTL_SECONDS=3600

# ===========================================
# Rate Limiting
# ===========================================
RATE_LIMIT_REQUESTS=60
RATE_LIMIT_WINDOW=60

# Authentication rate limiting (brute-force protection)
AUTH_RATE_LIMIT_ATTEMPTS=5
AUTH_RATE_LIMIT_WINDOW=60

# ===========================================
# Redis Configuration (for distributed rate limiting)
# ===========================================
# Required for multi-worker deployments to share rate limiting state
# Leave empty to use in-memory rate limiting (single worker only)
REDIS_URL=redis://localhost:6379/0

# Redis password (REQUIRED for Docker Compose)
# ⚠️ CRITICAL: Generate with: python -c "import secrets; print(secrets.token_urlsafe(24))"
REDIS_PASSWORD=CHANGE_ME_generate_secure_password_here

# ===========================================
# Monitoring (Grafana/Prometheus)
# ===========================================
# ⚠️ CRITICAL: Change default Grafana password before deploying!
# Generate with: python -c "import secrets; print(secrets.token_urlsafe(16))"
GRAFANA_ADMIN_USER=admin
GRAFANA_ADMIN_PASSWORD=CHANGE_ME_generate_secure_grafana_password

# ===========================================
# AI-Powered Selector Auto-Repair (optional)
# ===========================================
# Enable AI-powered selector auto-repair using Google GenAI SDK (unified SDK)
# Get API key from: https://ai.google.dev/
# Uses gemini-2.5-flash model (stable, production-ready)
GEMINI_API_KEY=your_gemini_api_key_here

# ===========================================
# Secret Management (HashiCorp Vault - Optional)
# ===========================================
# Enable Vault for secret management (requires hvac: pip install vfs-bot[vault])
# VAULT_ADDR=http://127.0.0.1:8200
# VAULT_TOKEN=your-vault-token
# VAULT_MOUNT_POINT=secret
