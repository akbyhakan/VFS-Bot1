#!/usr/bin/env python3
"""Check that critical paths in the codebase meet 100% line coverage requirements.

This script parses coverage.xml (generated by pytest-cov) and enforces
100% line coverage on security-critical and business-critical modules.
Exit code 0 means all critical paths pass; exit code 1 means at least one fails.
"""

import sys
import xml.etree.ElementTree as ET

# Critical paths that require 100% line coverage.
# Keys are path prefixes/substrings to match against the 'filename' attribute
# in coverage.xml; values are human-readable descriptions.
CRITICAL_PATHS: dict[str, str] = {
    "src/core/auth": "login/authentication",
    "src/services/bot/booking_workflow.py": "booking workflow",
    "web/routes/auth.py": "auth API routes",
}

COVERAGE_XML = "coverage.xml"
REQUIRED_THRESHOLD = 100.0


def parse_coverage(xml_path: str) -> list[dict]:
    """Parse coverage.xml and return a list of class coverage records.

    Args:
        xml_path: Path to the coverage.xml file.

    Returns:
        List of dicts with keys: filename, line_rate, branch_rate.
    """
    tree = ET.parse(xml_path)
    root = tree.getroot()
    records = []
    for cls in root.iter("class"):
        filename = cls.get("filename", "")
        line_rate = float(cls.get("line-rate", "0")) * 100
        branch_rate = float(cls.get("branch-rate", "0")) * 100
        records.append(
            {
                "filename": filename,
                "line_rate": line_rate,
                "branch_rate": branch_rate,
            }
        )
    return records


def check_critical_paths(records: list[dict]) -> bool:
    """Verify each critical path meets the 100% line coverage threshold.

    Args:
        records: Coverage records from parse_coverage().

    Returns:
        True if all critical paths pass, False otherwise.
    """
    all_pass = True

    for path_prefix, description in CRITICAL_PATHS.items():
        matched = [r for r in records if path_prefix in r["filename"]]

        if not matched:
            print(f"‚ö†Ô∏è  WARNING: Critical path not found in coverage report: {path_prefix} ({description})")
            continue

        for record in matched:
            line_rate = record["line_rate"]
            status = "PASS" if line_rate >= REQUIRED_THRESHOLD else "FAIL"
            icon = "‚úÖ" if status == "PASS" else "‚ùå"
            print(
                f"{icon} [{status}] {record['filename']} ‚Äî "
                f"line coverage: {line_rate:.1f}% (required: {REQUIRED_THRESHOLD:.0f}%)"
            )
            if status == "FAIL":
                all_pass = False

    return all_pass


def main() -> None:
    """Entry point: parse coverage.xml and enforce critical path thresholds."""
    try:
        records = parse_coverage(COVERAGE_XML)
    except FileNotFoundError:
        print(f"‚ùå Coverage file not found: {COVERAGE_XML}")
        print("   Run pytest with --cov-report=xml to generate it.")
        sys.exit(1)
    except ET.ParseError as exc:
        print(f"‚ùå Failed to parse {COVERAGE_XML}: {exc}")
        sys.exit(1)

    print(f"üìä Checking critical path coverage (threshold: {REQUIRED_THRESHOLD:.0f}%)...")
    print()

    all_pass = check_critical_paths(records)

    print()
    if all_pass:
        print("‚úÖ All critical paths meet the coverage threshold.")
        sys.exit(0)
    else:
        print("‚ùå One or more critical paths are below the required coverage threshold.")
        sys.exit(1)


if __name__ == "__main__":
    main()
